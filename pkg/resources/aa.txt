
func ProcessTypedConfigs(jsonStringStr string, typedConfigPath models.TypedConfigPath, logger *logrus.Logger) ([]*models.TypedConfig, map[string]*models.TypedConfig) {
	var typedConfigs []*models.TypedConfig
	typedConfigsMap := make(map[string]*models.TypedConfig)
	seenConfigs := make(map[string]struct{})

	if typedConfigPath.IsPerTypedConfig {
		if len(typedConfigPath.ArrayPaths) == 0 {
			result := gjson.Get(jsonStringStr, typedConfigPath.PathTemplate)
			if result.Exists() {
				result.ForEach(func(key, value gjson.Result) bool {
					dynamicKey := key.String()
					dynamicPath := fmt.Sprintf("%s.%s", typedConfigPath.PathTemplate, dynamicKey)
					processPath(jsonStringStr, dynamicPath, &typedConfigs, typedConfigsMap, seenConfigs, logger)
					return true
				})
			}
		} else {
			result := gjson.Get(jsonStringStr, typedConfigPath.ArrayPaths[0].ParentPath)
			if result.IsArray() {
				processPerTypedConfigArray(result.Array(), jsonStringStr, typedConfigPath.PathTemplate, typedConfigPath.ArrayPaths, &typedConfigs, typedConfigsMap, seenConfigs, logger)
			} else if result.Exists() {
				processDynamicKey(result, typedConfigPath.ArrayPaths[0].ParentPath, &typedConfigs, typedConfigsMap, seenConfigs, logger)
			}
		}
	} else {
		if len(typedConfigPath.ArrayPaths) == 0 {
			processPath(jsonStringStr, typedConfigPath.PathTemplate, &typedConfigs, typedConfigsMap, seenConfigs, logger)
		} else {
			result := gjson.Get(jsonStringStr, typedConfigPath.ArrayPaths[0].ParentPath)
			if result.IsArray() {
				processArray(result.Array(), jsonStringStr, typedConfigPath.PathTemplate, typedConfigPath.ArrayPaths, &typedConfigs, typedConfigsMap, seenConfigs, logger)
			} else if result.Exists() {
				processPath(result.String(), typedConfigPath.ArrayPaths[0].ParentPath, &typedConfigs, typedConfigsMap, seenConfigs, logger)
			}
		}
	}

	return typedConfigs, typedConfigsMap
}

// Dynamic key ile path işlemlerini işleyen fonksiyon
func processDynamicKey(result gjson.Result, basePath string, typedConfigs *[]*models.TypedConfig, typedConfigsMap map[string]*models.TypedConfig, seenConfigs map[string]struct{}, logger *logrus.Logger) {
	result.ForEach(func(key, value gjson.Result) bool {
		dynamicKey := key.String()
		dynamicPath := fmt.Sprintf("%s.%s", basePath, dynamicKey)
		processPath(result.String(), dynamicPath, typedConfigs, typedConfigsMap, seenConfigs, logger)
		return true
	})
}

// PerTypedConfig için dizi elemanlarını işleyen yardımcı fonksiyon
func processPerTypedConfigArray(array []gjson.Result, jsonStringStr string, pathTemplate string, arrayPaths []models.ArrayPath, typedConfigs *[]*models.TypedConfig, typedConfigsMap map[string]*models.TypedConfig, seenConfigs map[string]struct{}, logger *logrus.Logger) {
	placeholderCount := strings.Count(pathTemplate, "%d")

	for i := range array {
		combinations := generateIndexCombinations(jsonStringStr, arrayPaths)

		for _, indices := range combinations {
			if len(indices) == placeholderCount {
				indices[0] = i
				finalPath := fmt.Sprintf(pathTemplate, indices...)
				dynamicResult := gjson.Get(jsonStringStr, finalPath)

				if dynamicResult.Exists() {
					dynamicResult.ForEach(func(key, value gjson.Result) bool {
						dynamicKey := key.String()
						dynamicPath := fmt.Sprintf("%s.%s", finalPath, dynamicKey)
						processPath(jsonStringStr, dynamicPath, typedConfigs, typedConfigsMap, seenConfigs, logger)
						return true
					})
				}
			}
		}
	}
}